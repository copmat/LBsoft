
 program create_xyz
 
  implicit none
  
  integer :: nx=64
  integer :: ny=64
  integer :: nz=64
  
  integer :: ntot,i,j,k,natms
  integer, parameter :: imcon=2
  integer, parameter :: idrank=0
  
  integer, parameter :: ioxyz=16
  character(len=*), parameter :: filexyz='input.xyz'
  
  real(kind=8), parameter :: & 
   Pi=3.141592653589793238462643383279502884d0
   
  integer, parameter :: maxlen=85
  real(kind=8) :: rcut,dtemp_1,dtemp_2,dtemp_3,cell(9),sqrcut,rdist
  real(kind=8), allocatable, dimension(:) :: xxx,yyy,zzz,vxx,vyy,vzz
  
  character(len=maxlen) :: arg,redstring,directive
  logical :: safe,lcheck,ltest
  integer :: idum,iseed,inumchar
   
  if(iargc()/=6)then
    write(6,*) 'error!'
    write(6,*) 'the command line should be'
    write(6,*) '[executable] [natms] [nx] [ny] [nz] [seed] [rcut]'
    write(6,*) 'natms = integer indicating the number of particle'
    write(6,*) 'nx    = integer indicating the box lenght along y'
    write(6,*) 'ny    = integer indicating the box lenght along y'
    write(6,*) 'nz    = integer indicating the box lenght along z'
    write(6,*) 'seed  = seed of the random generator             '
    write(6,*) 'rcut  = float indicating the largest distance where compute gor'
    write(6,*) 'STOP!'
    stop
  endif
  
  
  
  do i = 1, iargc()
    call getarg(i, arg)
    if(i==1)then
      call copystring(arg,directive,maxlen)
      natms=intstr(directive,maxlen,inumchar)
      write(6,*) 'natms = ',natms
    elseif(i==2)then
      call copystring(arg,directive,maxlen)
      nx=intstr(directive,maxlen,inumchar)
      write(6,*) 'nx    = ',nx
    elseif(i==3)then
      call copystring(arg,directive,maxlen)
      ny=intstr(directive,maxlen,inumchar)
      write(6,*) 'ny    = ',ny
    elseif(i==4)then
      call copystring(arg,directive,maxlen)
      nz=intstr(directive,maxlen,inumchar)
      write(6,*) 'nz    = ',nz
    elseif(i==5)then
      call copystring(arg,directive,maxlen)
      iseed=intstr(directive,maxlen,inumchar)
      write(6,*) 'seed    = ',iseed
    elseif(i==6)then
      call copystring(arg,directive,maxlen)
      rcut=dblstr(directive,maxlen,inumchar)
      write(6,*) 'rcut  = ',rcut
    endif
  enddo
  
  call init_random_seed(iseed)
  
  allocate(xxx(natms),yyy(natms),zzz(natms),vxx(natms),vyy(natms), &
   vzz(natms))
   
  cell(:)=0.d0
  cell(1)=dble(nx)+1.d0
  cell(5)=dble(ny)+1.d0
  cell(9)=dble(nz)+1.d0
  
  sqrcut=rcut**2.d0
  
  do i=1,natms
    lcheck=.true.
    do while(lcheck)
      call random_number(dtemp_1)
      call random_number(dtemp_2)
      call random_number(dtemp_3)
      dtemp_1=dtemp_1*(dble(nx)+0.5d0)+0.5d0
      dtemp_2=dtemp_2*(dble(ny)+0.5d0)+0.5d0
      dtemp_3=dtemp_3*(dble(nz)+0.5d0)+0.5d0
      
        do j=1,i-1
          vxx(j)=(xxx(j)-dtemp_1)
          vyy(j)=(yyy(j)-dtemp_2)
          vzz(j)=(zzz(j)-dtemp_3)
        enddo
        if(i-1>0)call images_mio(imcon,i-1,cell,vxx,vyy,vzz)
        ltest=.true.
        do j=1,i-1
          rdist=vxx(j)**2.d0+vyy(j)*2.d0+vzz(j)**2.d0
          if(rdist<=sqrcut)then
            ltest=.false.
            exit
          endif
        enddo
        if(ltest)then
          lcheck=.false.
          xxx(i)=dtemp_1
          yyy(i)=dtemp_2
          zzz(i)=dtemp_3
        endif
      
    enddo
  enddo
  
  do i=1,natms
    vxx(i)=0.02d0*gauss()
    vyy(i)=0.02d0*gauss()
    vzz(i)=0.02d0*gauss()
  enddo
  
  open(unit=ioxyz,file=filexyz,status='replace',action='write')
  
  write(ioxyz,'(i8)')natms
  
  write(ioxyz,'(a)')' read list vx vy vz '
  
  do i=1,natms
    write(ioxyz,'(a8,6f16.8)')'C       ',xxx(i),yyy(i),zzz(i), &
     vxx(i),vyy(i),vzz(i) 
  enddo
  
  close(ioxyz)
  
  stop
  
 contains
 
 subroutine init_random_seed(myseed)
 
!***********************************************************************
!     
!     LBsoft subroutine for initialising the random generator
!     by the seed given in input file or by a random seed
!     originally written in JETSPIN by M. Lauricella et al.
!     
!     licensed under Open Software License v. 3.0 (OSL-3.0)
!     author: M. Lauricella
!     last modification July 2018
!     
!***********************************************************************
  
  implicit none
  
  integer,intent(in),optional :: myseed
  integer :: i, n, clock
  
  integer, allocatable :: seed(:)
          
  call random_seed(size = n)
  
  allocate(seed(n))
  
  if(present(myseed))then
!   If the seed is given in input
    seed = myseed*(idrank+1) + 37 * (/ (i - 1, i = 1, n) /)
    
  else
!   If the seed is not given in input it is generated by the clock
    call system_clock(count=clock)
         
    seed = clock*(idrank+1) + 37 * (/ (i - 1, i = 1, n) /)
    
  endif
  
  call random_seed(put = seed)
       
  deallocate(seed)
  
  return
 
 end subroutine init_random_seed
 
 function gauss()
 
!***********************************************************************
!     
!     LBsoft subroutine for generating random number normally
!     distributed by the Box-Muller transformation
!     originally written in JETSPIN by M. Lauricella et al.
!     
!     licensed under Open Software License v. 3.0 (OSL-3.0)
!     author: M. Lauricella
!     last modification July 2018
!     
!***********************************************************************
  
  implicit none
  
  real(kind=8) :: gauss
  real(kind=8) :: dtemp1,dtemp2
  logical :: lredo
  
  call random_number(dtemp1)
  call random_number(dtemp2)
  
  lredo=.true.
  
! the number is extract again if it is nan
  do while(lredo)
    lredo=.false.
!   Box-Muller transformation
    gauss=dsqrt(- 2.d0 *dlog(dtemp1))*dcos(2*pi*dtemp2)
    if(isnan(dcos(gauss)))lredo=.true.
  enddo
  
 end function gauss
 
 subroutine copystring(oldstring,newstring,lenstring)
 
!***********************************************************************
!     
!     JETSPIN subroutine to copy one character string into another
!     
!     licensed under Open Software License v. 3.0 (OSL-3.0)
!     author: M. Lauricella
!     last modification March 2015
!     
!***********************************************************************
  
  implicit none
  
  character(len=*), intent(in) :: oldstring
  character(len=*), intent(out) :: newstring
  integer, intent(in) :: lenstring
  
  integer :: i
  
  do i=1,lenstring
    newstring(i:i)=oldstring(i:i)
  enddo
  
  return
  
 end subroutine copystring
 
 function intstr(string,lenstring,laststring)
 
!***********************************************************************
!     
!     JETSPIN subroutine for extracting integers from a character 
!     string
!     
!     licensed under Open Software License v. 3.0 (OSL-3.0)
!     author: M. Lauricella
!     last modification March 2015
!     
!***********************************************************************
  
  implicit none
  
  character(len=*), intent(inout) :: string
  integer, intent(in) :: lenstring
  integer, intent(out) :: laststring
  
  integer :: intstr
  
  integer :: j,isn
  character*1, parameter, dimension(0:9) :: & 
   n=(/'0','1','2','3','4','5','6','7','8','9'/)
  logical :: flag,lcount,final
  character*1 :: ksn
  character*1, dimension(lenstring) :: word
  
  do j=1,lenstring
    word(j)=string(j:j)
  enddo
  
  isn=1
  laststring=0
  ksn='+'
  intstr=0
  flag=.false.
  final=.false.
  lcount=.false.
  
  
  do while(laststring<lenstring.and.(.not.final))
    
    laststring=laststring+1
    flag=.false.
    
    do j=0,9
      
      if(n(j)==word(laststring))then
        
        intstr=10*intstr+j
        lcount=.true.
        flag=.true.
        
      endif
    
    enddo
    
    if(lcount.and.(.not.flag))final=.true.
    if(flag .and. ksn=='-')isn=-1
    ksn=word(laststring)
    
  enddo

  intstr=isn*intstr

  do j=laststring,lenstring
    word(j-laststring+1)=word(j)
  enddo
  do j=lenstring-laststring+2,lenstring
    word(j)=' '
  enddo
  
  do j=1,lenstring
    string(j:j)=word(j)
  enddo
  
  return
  
  end function intstr

  function dblstr(string,lenstring,laststring)
  
!***********************************************************************
!     
!     JETSPIN subroutine for extracting double precisions from a  
!     character string
!     
!     licensed under Open Software License v. 3.0 (OSL-3.0)
!     author: M. Lauricella
!     last modification March 2015
!     
!***********************************************************************
  
  implicit none
  
  character(len=*), intent(inout) :: string
  integer, intent(in) :: lenstring
  integer, intent(out) :: laststring
  
  double precision :: dblstr
  
  logical :: flag,ldot,start,final
  integer :: iexp,idum,i,j,fail
  double precision :: sn,ten,one

  character*1, parameter, dimension(0:9) :: & 
   n=(/'0','1','2','3','4','5','6','7','8','9'/)
  character*1, parameter :: dot='.'
  character*1, parameter :: d='d'
  character*1, parameter :: e='e'
  
  character*1 :: ksn
  character*1, dimension(lenstring) :: word
  character(len=lenstring) :: work
  
  do j=1,lenstring
    word(j)=string(j:j)
  enddo

  laststring=0
  sn=1.d0
  ksn='+'
  ten=10.d0
  one=1.d0
 
  dblstr=0.d0
  iexp=0
  idum=0
  start=.false.
  ldot=.false.
  final=.false.
  
  do while(laststring<lenstring .and. (.not.final))
    
    laststring=laststring+1
    flag=.false.
    
    do j=0,9
      
      if(n(j)==word(laststring))then
        
        dblstr=ten*dblstr+one*dble(j)
        flag=.true.
        start=.true.
            
      endif
          
    enddo
        
    if(dot==word(laststring))then
          
      flag=.true.
      ten=1.d0
      ldot=.true.
      start=.true.
          
    endif

    if(flag .and. ksn=='-') sn=-1.d0
    if(ldot)one=one/10.d0
    ksn=word(laststring)
    if(ksn=="D")ksn="d"
    if(ksn=="E")ksn="e"
    
    if(start)then
      if(d==ksn .or. e==ksn)then
        do i=1,lenstring-laststring
          work(i:i)=word(i+laststring)
        enddo
        iexp=intstr(work,lenstring-laststring,idum)
        final=.true.
      endif
      if(.not.flag)final=.true.        
    endif
  enddo
  
  dblstr=sn*dblstr*(10.d0**iexp)
  laststring=laststring+idum
  
  do j=laststring,lenstring
    word(j-laststring+1)=word(j)
  enddo
  do j=lenstring-laststring+2,lenstring
    word(j)=' '
  enddo
  
  do j=1,lenstring
    string(j:j)=word(j)
  enddo
  
  return
  
 end function dblstr

 subroutine strip(string,lenstring)

  implicit none
  
  character(len=*) :: string
  integer, intent(in) :: lenstring
  
  integer :: i,j
  character*1, dimension(lenstring) :: word
  
  do j=1,lenstring
    word(j)=string(j:j)
  enddo 
  
  do i=1,lenstring
    
    if(word(1)==' ')then
      
      do j=1,lenstring-1
        
        word(j)=word(j+1)
        
      enddo
      
      word(lenstring)=' '
      
    endif
    
  enddo
  
  do j=1,lenstring
    string(j:j)=word(j)
  enddo
  
  return
  
 end subroutine strip
 
 subroutine images_mio(imconsub,natmssub,cellsub,xxx,yyy,zzz)
      
!***********************************************************************
!     
!     subroutine for calculating the minimum image
!     of atom pairs within a specified MD cell
!     
!     copyright - daresbury laboratory 1992
!     author    - w. smith march 1992.
!     T3D optimised version. t.forester july 1994
!     serial version M. Lauricella 2016
!     
!     for
!     imconsub=0 no boundary conditions apply
!     imconsub=1 standard cubic boundaries apply
!     imconsub=2 orthorhombic boundaries apply
!     imconsub=3 parallelepiped boundaries apply
!     imconsub=4 truncated octahedron boundaries apply
!     imconsub=5 rhombic dodecahedron boundaries apply
!     imconsub=6 x-y parallelogram boundary conditions : no periodicity in z
!     imconsub=7 hexagonal prism boundaries apply
!     
!     note: in all cases the centre of the cell is at (0,0,0)
!     warning - replicated data version: does not re-merge 
!     coordinate arrays
!     
!***********************************************************************

      
  implicit none
  
  integer, intent(in) :: imconsub,natmssub
  double precision, dimension(9), intent(in) :: cellsub
  integer :: i
  double precision, allocatable, dimension(:), intent(inout) ::  xxx,yyy,zzz
  double precision ::aaa,bbb,ccc,det,ssx
  double precision :: ssy,ssz,ddd,xss,yss,zss
  
  double precision :: rcellsub(9)
  double precision, parameter :: rt2=1.41421356623d0
  double precision, parameter :: rt3=1.7320508075d0
  
      
  if(imconsub.eq.1)then

!   standard cubic boundary conditions
        
        
    aaa=1.d0/cellsub(1)
    
    do i=1,natmssub
      xxx(i)=xxx(i)-cellsub(1)*nint(aaa*xxx(i))
      yyy(i)=yyy(i)-cellsub(1)*nint(aaa*yyy(i))
      zzz(i)=zzz(i)-cellsub(1)*nint(aaa*zzz(i))
    enddo
        
  else if(imconsub.eq.2)then

!   rectangular (slab) boundary conditions
        
    aaa=1.d0/cellsub(1)
    bbb=1.d0/cellsub(5)
    ccc=1.d0/cellsub(9)
        
    do i=1,natmssub
      
      xxx(i)=xxx(i)-cellsub(1)*nint(aaa*xxx(i))
      yyy(i)=yyy(i)-cellsub(5)*nint(bbb*yyy(i))
      zzz(i)=zzz(i)-cellsub(9)*nint(ccc*zzz(i))
          
    enddo
      
  else if(imconsub.eq.3)then

!   parallelepiped boundary conditions
        
    call invert(cellsub,rcellsub,det)
        
    do i=1,natmssub
          
      ssx=(rcellsub(1)*xxx(i)+rcellsub(4)*yyy(i)+rcellsub(7)*zzz(i))
      ssy=(rcellsub(2)*xxx(i)+rcellsub(5)*yyy(i)+rcellsub(8)*zzz(i))
      ssz=(rcellsub(3)*xxx(i)+rcellsub(6)*yyy(i)+rcellsub(9)*zzz(i))
          
      xss=ssx-nint(ssx)
      yss=ssy-nint(ssy)
      zss=ssz-nint(ssz)
          
      xxx(i)=(cellsub(1)*xss+cellsub(4)*yss+cellsub(7)*zss)
      yyy(i)=(cellsub(2)*xss+cellsub(5)*yss+cellsub(8)*zss)
      zzz(i)=(cellsub(3)*xss+cellsub(6)*yss+cellsub(9)*zss)
          
    enddo
        
  else if(imconsub.eq.4)then

!   truncated octahedral boundary conditions
        
    if(.not.(abs(cellsub(1)-cellsub(5)).lt.1.d-6.and. &
     abs(cellsub(5)-cellsub(9)).lt.1.d-6))then
      write(6,'(2a)')'.not.(abs(cellsub(1)-cellsub(5)).lt.1.d-6.and.', &
       'abs(cellsub(5)-cellsub(9)).lt.1.d-6)'
      stop
    endif
        
    aaa=1.d0/cellsub(1)
        
    do i=1,natmssub
          
      xxx(i)=xxx(i)-cellsub(1)*nint(aaa*xxx(i))
      yyy(i)=yyy(i)-cellsub(1)*nint(aaa*yyy(i))
      zzz(i)=zzz(i)-cellsub(1)*nint(aaa*zzz(i))
          
      if((abs(xxx(i))+abs(yyy(i))+abs(zzz(i))).ge.(0.75d0*cellsub(1)))then
            
        xxx(i)=xxx(i)-0.5d0*sign(cellsub(1),xxx(i))
        yyy(i)=yyy(i)-0.5d0*sign(cellsub(1),yyy(i))
        zzz(i)=zzz(i)-0.5d0*sign(cellsub(1),zzz(i))
            
      endif
          
    enddo
        
  else if(imconsub.eq.5)then

!   rhombic dodecahedral boundary conditions
        
    if(.not.(abs(cellsub(1)-cellsub(5)).lt.1.d-6.and. &
     abs(cellsub(9)-cellsub(1)*rt2).lt.1.d-6))then
      write(6,'(2a)')'.not.(abs(cellsub(1)-cellsub(5)).lt.1.d-6.and.', &
       'abs(cellsub(9)-cellsub(1)*rt2).lt.1.d-6)'
      stop
    endif
        
    aaa=1.d0/cellsub(1)
    bbb=1.d0/cellsub(9)
        
    do i=1,natmssub
          
      xxx(i)=xxx(i)-cellsub(1)*nint(aaa*xxx(i))
      yyy(i)=yyy(i)-cellsub(1)*nint(aaa*yyy(i))
      zzz(i)=zzz(i)-cellsub(9)*nint(bbb*zzz(i))
          
      if((abs(xxx(i))+abs(yyy(i))+abs(rt2*zzz(i))).ge.cellsub(1))then
            
        xxx(i)=xxx(i)-0.5d0*sign(cellsub(1),xxx(i))
        yyy(i)=yyy(i)-0.5d0*sign(cellsub(1),yyy(i))
        zzz(i)=zzz(i)-0.5d0*sign(cellsub(9),zzz(i))
            
      endif
          
    enddo
        
  else if(imconsub.eq.6) then

!   x-y boundary conditions 

    det = cellsub(1)*cellsub(5) - cellsub(2)*cellsub(4)

    if(abs(det).lt.1.d-6)then
      write(6,'(a)')'abs(det).lt.1.d-6'
      stop
    endif
        
    det = 1.d0/det

    rcellsub(1) =  det*cellsub(5)
    rcellsub(2) = -det*cellsub(2)
    rcellsub(4) = -det*cellsub(4)
    rcellsub(5) =  det*cellsub(1)
        
    do i=1,natmssub

      ssx = rcellsub(1)*xxx(i) + rcellsub(4)*yyy(i)
      ssy = rcellsub(2)*xxx(i) + rcellsub(5)*yyy(i)

      xss = ssx - nint(ssx)
      yss = ssy - nint(ssy)

      xxx(i)=cellsub(1)*xss + cellsub(4)*yss
      yyy(i)=cellsub(2)*xss + cellsub(5)*yss

    enddo

  else if(imconsub.eq.7) then

!   hexagonal prism boundary conditions
        
    if(abs(cellsub(1)-rt3*cellsub(5)).ge.1.d-6)then
      write(6,'(a)')'abs(cellsub(1)-rt3*cellsub(5)).ge.1.d-6'
      stop
    endif
        
    aaa=cellsub(1)/(rt3*2.d0)
    bbb=cellsub(1)/rt3
    ccc=rt3/cellsub(1)
    ddd=1.d0/cellsub(9)
        
    do i=1,natms
          
      yyy(i)=yyy(i)-bbb*nint(ccc*yyy(i))
      zzz(i)=zzz(i)-cellsub(9)*nint(ddd*zzz(i))
          
      if((abs(yyy(i))+abs(rt3*xxx(i))).ge.bbb)then
            
        xxx(i)=xxx(i)-rt3*sign(aaa,xxx(i))
        yyy(i)=yyy(i)-sign(aaa,yyy(i))
            
      endif
          
    enddo
        
  endif
      
  return

 end subroutine images_mio
 
 subroutine invert(a,b,d)

!***********************************************************************
!     
!     dl_poly subroutine to invert a 3 * 3 matrix using cofactors
!     
!     copyright - daresbury laboratory 1992
!     author    - w. smith       april 1992
!     
!***********************************************************************

  implicit none

  double precision :: a(9),b(9),d,r


! calculate adjoint matrix
  b(1)=a(5)*a(9)-a(6)*a(8)
  b(2)=a(3)*a(8)-a(2)*a(9)
  b(3)=a(2)*a(6)-a(3)*a(5)
  b(4)=a(6)*a(7)-a(4)*a(9)
  b(5)=a(1)*a(9)-a(3)*a(7)
  b(6)=a(3)*a(4)-a(1)*a(6)
  b(7)=a(4)*a(8)-a(5)*a(7)
  b(8)=a(2)*a(7)-a(1)*a(8)
  b(9)=a(1)*a(5)-a(2)*a(4)

! calculate determinant
  d=a(1)*b(1)+a(4)*b(2)+a(7)*b(3)
  r=0.d0
  if(abs(d).gt.0.d0)r=1.d0/d

! complete inverse matrix
  b(1)=r*b(1)
  b(2)=r*b(2)
  b(3)=r*b(3)
  b(4)=r*b(4)
  b(5)=r*b(5)
  b(6)=r*b(6)
  b(7)=r*b(7)
  b(8)=r*b(8)
  b(9)=r*b(9)

  return
  
 end subroutine invert
  
 end program create_xyz
 
 
  
